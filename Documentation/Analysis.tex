\documentclass[11pt]{article}
\usepackage[top=1in, bottom=1in, left=1in, right=1in]{geometry}
\usepackage{listings}
\usepackage{setspace}
\usepackage{color}

\renewcommand{\baselinestretch}{1.4}
\setlength{\parskip}{0.8em}
 
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{codestyle}{
	language=Java,
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\footnotesize\ttfamily,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
\lstset{style=codestyle}

\newcommand{\quotes}[1]{``#1"}

\begin{document}

\begin{center}
\textbf{ECE 458: Engineering Software For Maintainability \\
Senior Design Course\\
Spring 2015\\[0.2in]}
Evolution 1 Analysis\\
Brian Bolze, Jeff Day, Henrique Rusca, Wes Koorbusch
\end{center}

\singlespacing
\tableofcontents

% Writen Analysis (25%) Along with every software deliverable, you will turn in a written docu- ment which will cover two main points:

% 1. A retrospective on how your previous design choices impacted your work to meet the current set of requirements. This section should analyze not only where your good design choices made things easy, but also where your bad design choices made things hard. For both of these points, you should analyze how/why these design choices helped or hindered you. For bad design choices, you should discuss what you might have done differently in the past to avoid the problem this time around.

% 2. An evaluation of your current design, with an analysis of its strengths and weaknesses going forwards. This section should justify your current design choices, explaining why you think they will be beneficial to you in the long run. If you recognize weaknesses in your current design, you should discuss them—including an explanation of why they are there, and how you plan to fix them in future submissions.

% These documents should not only deep analysis of the strengths and weaknesses of your design choice, but also be well written. Ideally, the retrospective section of submission N would connect back to the forward-looking analysis of submission N-1 (i.e., Did things you think would be beneficial actually end up helping you? Did the weaknesses you identified come back to bite you? Did you fix your weaknesses this time around?).

\pagebreak

\section{Introduction}

Good software design is often seen not only as a science but as an art. It is a craft and, like any other type of engineering, is only mastered over time. The fundamentals of good software design, however, remain sound. In this senior design course, we plan on synthesizing our four years of knowledge through the development of a robust and long-lasting software application implementing a web-based calendar. We plan on applying the core principles of good design to our code and to our design process, while continuously evaluating, refining, and improving on our skills of the software engineering trade. 

For our project, we built an application using the Ruby on Rails framework. This framework aided us in developing highly modular and reusable code due to the MVC architecture and Rails' powerful web application stack. With the additional help of great documentation and a strong community, we were able to develop a functional product within weeks, despite minimal domain expertise. While our current application has noticeable areas for improvement, our robust model, well thought out API, and extensive front-end templates promise a maintainable foundation for future development. 

\section{Project Plan}

\subsection{Design Goals}

In order to set ourselves up for a successful project, it was really important to us that we lay out our design goals and priorities before moving forward. We aimed at grounding our design discussions in the fundamentals, which we hoped would help us set up a solid foundation for a project of such a significant size. The core design principles that we focused on primarily were modularity (Open-Closed Principle), re-usability, and the DRY principle. Another consideration that we put a lot of thought into was our language and framework choice, which will be expanded on in the next section. Besides promoting good code design, a well-chosen framework would allow us to get up to speed quickly, which was another important criteria for our team given our experience level with web applications. During our initial stages, a particular focus was placed on developing a robust, accurate, and extensible model for our data. This would lay the groundwork for our API with the front-end components, which we saw as vital to our success down the line. 


\subsection{Language Choice}

% RoR vs Django

% RoR design philosophy
%%% SHY
%%% MVC
%%% Convention over Configuration

%% Modular -- independence --> work by ourselves
%% DRY --> keep business logic in the model, filters in controller
%% Reusable --> Partials in View

% Ruby
%%% Dynamically typed
%%% embedded ruby...

The language decision was extremely important for our group for a few reasons. Firstly, no one in our group had previous experience in developing web applications. Accordingly, we stressed finding a language and framework with a strong community, good documentation, and abundant resources. Secondly, seeing as our project would be maintained over an entire semester, we strived to find an environment that would support and promote good design practices. To do this, we would need a language with strong object orientation and a framework with a highly modular architecture. Lastly, we also needed the flexibility to implement our application with high customizability to meet any obscure requirements. After extensive research and testing, we found that Ruby on Rails was able to meet our needs better than any other framework. 

% originally started with Django, chiefly because two members of the team had a strong background in Python, but did not turn out to be much of an advantage
% switched over due to roadblocks getting off the ground
% Realized rails had larger community, better documentation, and Rails is a widely sought out skill so we wanted to learn about it
% Integrated test modules + fixtures

\section{Design}

As a result of utilizing the Ruby on Rails framework, we separated our program into four distinct large scale sections: the Model, View, Controller, and Database.  A majority of our first evolution design consisted of developing our models and database schemas from the model.  In the design of our model, we wanted to make sure that each component we created could have a clear relationship to every other component that was necessary in the design requirements.  In order to make these relationships flexible and dynamic, we took to heart a computer science principle that has been driven into us by many of our professors: the solution in a level of indirection.

The design of our code improved significantly since evolution 1. After actually taking time to learn what the rails framework provides us, we were able to write cleaner and more efficient code.

\subsection{Views}

For views, Rails provides the use of partials, helpers, assets, and layouts. These features all come together to allow the developer to create a powerful interface. Rails motto of not repeating yourself allows for efficient interface implementation with a great deal of reusable code.

Layouts can be considered the beginning and end of the html file rendered on screen. With them we are able to render the navigation bar along with any error and notification that comes from an action on the application, since this view code wraps all the rest. On the body of the layout structure, the file yields to the corresponding html file that should be rendered on thee session. Within an html view, we can render several partials, which are basically the opposite of the layout. Instead of wrapping the html file, it is embedded in it. Therefore, we are able to render any piece of html.erb (embedded ruby) code within the html file. This proves to be extremely useful for generating forms. For example, the forms for generating and editing a to-do (how we called PUD event) should have the same fields with the exception of header information and the method called on the controller upon the form submission. Another good use of partials is on the events index page. We have added a new visualization through a list of events and segregated them according to visibility. It would consume a lot of code to rewrite the layout for each event every time. Therefore, for each section of visibility, a new partial is rendered because the event information is the same. Helpers work in a similar way that it allows certain methods to be called from views to perform a certain tasks. In our code, for instance, we call a helper to render an error message in case an error carried from the previous page.

Besides layouts and partials, it is important to notice that embedded ruby files allow us to insert ruby code to create dynamic html files. For instance, we can perform a for loop to iterate over the current events and display their information. Also, Rails provides frameworks to generate forms that provides checkboxes, selections, text fields, date time selections, among other things to later perform mass assignment on the controller, preventing the tedious creation of setting each parameter of an object upon creation or update.

Assets are another important cog for a Rails application. All the js, css, and images are included within the assets folder. Rails make use of asset pipelining to precompile all the assets into a single optimized file so the browser can cache it and not make any further requests. The js in the application is used for popup forms and calendar presentation, while the css is, obviously, used for styling.

\subsection{Controllers}

Rails emphasizes how controllers should be kept with a minimum amount of work. Controllers are basically responsible for extracting the variables that the view will use and redirect the browser based on user action and input condition. Also, bear in mind that complex queries for the extraction of the view’s variables are all moved to the models and placed into methods. The controllers of the application perform their function as demanded however Rails does not fail to warn that the implementation practices are not perfect. Sometimes a controller has to handle more than one model at once. For instance, to created a requested event, the controller should create the event itself, a request_map, and the requests to be sent to the corresponding users. Nevertheless, we try to keep that logic to a minimum by letting the request_map take the responsibility of creating its own requests by just passing the ids of the users.

Another important point to notice is that Rails recommends that max amount of shared variables between the controller and the view is constrained to two. However, in some cases this is simply not possible. For instance, the events controller segregates arrays of events by visibility for presentation. It is better to extract and separate each type of event into a different array rather than letting the view make difficult queries and figure where to place the next event on the iteration.

\subsection{Models}

Rails provides a solid framework for models to know where they stand. Rails make use of active records pattern to make a model communicate directly with its database counterpart. Also, ActiveRecords on rails offer validation calls to ensure the data inputted is exactly according to the developer’s conditions. If it is an integer, we can define a minimum and a maximum, if it is a string, we can constrain the length and so on. Therefore, we make use of those validations to ensure there are no surprises while retrieving data.

ActiveRecords allow to define a relation between themselves and other ActiveRecords on the database as long as the have the right column name for it. But Rails not only provides a relationship for one-to-many, one-to-one, and many-to-many, but also provides a through relation. It allows an ActiveRecord to reference another one through an intermediary table on the database. This design eases the use of complex queries and simplifies the code greatly upon implementation. For instance, Events can refer directly to their subscribers (Users) without us writing any code to fetch data from the ‘subscriptions’ table. The joins are made automatically. Another example is the groups table, which can access its members (also Users) directly without retrieving membership models.

A very important part of active records are their callbacks. It is possible do define a method to be called before or after any validation, creation, update, or deletion. These callbacks are fundamental for the cohesion of the database and are a great asset towards design. Methods and configuration can be called automatically over active records without the intervention of controllers. For instance, a To-Do verifies the next time it should be scheduled before creation in case it is recurrent, and reschedules itself if needed before an update (i.e. marked as done). For To-Do allocated events, they verify that their duration is a minimum of 15 minutes before validation and fetches the next to-do based on priority after creation. Finally, a reminder takes care of scheduling its notification task upon creation and unscheduling the task upon destruction to avoid emails of non-existent events.

Last important point of ActiveRecords are dependencies. We are able to specify the dependencies of relation between ActiveRecords and how the deletion of one should affect its related tables. Therefore, we are able to cascade deletions and get rid of potential memory leaks in the database without much trouble. For instance, if a user is deleted, it consequently deletes its created events, that deletes its related request map and requests, to-do items, and subscriptions. To-dos and subscriptions in turn destroy their respective reminders, which get unscheduled before destruction. Therefore, one could argue that the database has a considerably cohesive structure.

\subsection{Database}

The design of the database changed drastically since evolution 1. It got much more complex and with the help of active records callbacks and dependencies, it becomes self-maintainable in many points. Each ActiveRecord has its corresponding table and relations. Those are:

\begin{itemize}
  \item User: holds user general information along with the current session. A user has many created events and subscriptions to other user created events. It holds many memberships to groups defined by other users and many self-created to-dos. It also has many visibilities applied to him specifically regarding someone else’s event and several requests made by another person to him. A user model is responsible for retrieving any type of event with a certain characteristic related to him. Also, it creates and removes its own subscription.
  \item Event: Holds the general information of an event. It belongs to a creator, which is a User model. It holds many subscriptions made by other users to it and has many possible visibilities applied to it. It contains one to-do in case it is a to-do event or one request_map in case it is a requested event. A column event_type helps discern what type of event we are dealing with so we can present and consider it properly. We thought this design would be better rather than creating several event tables for each type and querying different tables to get essentially the same object. We let the event set itself up depending on its type. For instance, when a to-do event is created, it takes care of setting its title and description automatically based on the fetched to-do. Right now, the three possible types are ‘regular’, ‘to_do’, and ‘request’.
  \item Group: represents a group with a name to which one can assign several members for organization. A group is linked to many memberships as it is a many-to-many relationship with Users. A group also has many visibilities as a visibility rule of an event can be assigned to whole groups
  \item Membership: table that maps the many-to-many relationship between users and grops
  \item Subscription: table that maps the many-to-many relationship between users and events. If the user has a subscription, the event will be displayed for him if the visibility is not private. A subscription also holds a reminder, so each user can set his own reminder to a specific event.
  \item Visibility: represents one visibility rule applied to one event by its creator. An event can have several visibilities and can have them ordered in whichever way the user wants. We make use of the act_as_list gem that orders the visibility by position, scopes unique values by its corresponding event, and rearranges all positions once one of the visibilities position is changed, allowing for always having a set of visibilities in a clearly defined order. A visibility can either belong to a user or group. We decided to not break a group in its members and assign several visibilities because if a user would try to move the position of a whole group visibility, it would be hard to keep track of the new position of each member that pertains to that group. We make use of enums mapped directly to a status column to discern the different visibilities
  \item RequestMap: is basically a modularization level to manage the requests for an event. This way, an event that is not a request does not need to carry unnecessary behavior or information besides a request_map_id. It holds the relation to its many requests and is able to retrieve requests by status and create new ones for a given set of users
  \item Request: model that most importantly holds a state for the views and controllers to handle the behavior of a user towards an event. A request holds its corresponding request_map and user, and contains a status column to discern whether it is pending, confirmed, declined, removed, or with a requested modification
  \item ToDo: is an asynchronous model that can be optionally embedded in an event. Much like a visibility, it also makes use of the acts_as_list gem to order the to-dos of a user by priority in a cohesive manner. If a to-do event is allocated, it automatically fetches the next to-do on the priority list that is not done and is not assigned to another event already. It holds its own creator id and has a column to define its optional recurrence. After the event gets done, it verifies if the recurrence time has elapsed since creation. If so, it immediately creates a new to-do with the same parameters. If not, it schedules the creation of another to-do to the proper time. It contains an optional reminder as well with recurrent characteristics
  \item Reminder: Handles email notifications for either a subscription or a to-do. After creation, it schedules the right reminder based on the presence of a foreign key to either object. It holds a start_time and a recurrence value for the initial and subsequent notifications. For scheduling, we use the rufus_scheduler ruby gem
\end{itemize}

\section{Design Process Notes}

\subsection{Designed and Conducted Experiment}

\textit{Brian's Contribution}

One of the components of the project that I worked on heavily was the model. One of the few annoyances of Rails, however, is in how it separates out its model files from the underlying database migration files. This made it very difficult to keep track of the attributes and associations with each of the models. In order to ensure that the work on the model was accurate and would not break any other parts of the system, I decided to write a collections of tests. One of the benefits of RoR is the integrated test environment. It allows a developer to write tests for models, controllers, and other components at varying granularities, as well as seed the database with sample data using \textit{fixtures}. After writing a suite of tests for the model and running them against a few fixtures, I was able to quickly identify and resolve some errors in the way we were performing associations in the model. After running this experiment I was motivated to continue writing tests for controller components and others, which we can check in on continuously. 

\textit{Jeff's Contribution}

Once the team finalized our schema for the database, we began developing individual aspects of the entire design on each of our own git branches.  However, we noticed that when testing newly added features on our own individual branches, the database would for some reason roll back to an older version of the database that would cause the website to break.  For a very long time, we thought it was because the database schema and model files were being transferred over to new branches incorrectly.  However, after trying to implement new features on both individual branches and on the master branch, we realized that in order to update the database layout using rake db:migrate (the rails command to automatically update the database) on an individual branch, both the migrations and the database files needed to be committed to master whereas we were only committing the schema files.  After running the experiment of developing on two different branches and seeing the different outcomes (along with some help from stackoverflow), we were able to solve this bug using an experiment.

\textit{Henrique's Contribution}

I have spent some nights trying to get a calendar interface up and running on Django with no luck. I got the impression that the Django community was not big enough and several of its libraries were outdated. I have tried implementing Django-schedule and Django-scheduler only to later find a blog implementing an HTML Calendar and claiming that the mentioned libraries have not been maintained for over a year. Therfore I have decided to put up a Rails project in parallel and, if successful, I would present the proposal to my team to shift our core language. Overnight I was able to get the project up and running with a basic calendar interface.The next step would be to fill the calendar with created events, so I started conducting some trials. Firstly, I would create events through the terminal in a sandbox environment, then I moved to a development enviroment on the terminal to finally start adding events graphically.

\subsection{Analyzed and Interpreted Data}

\textit{Brian's Contribution}

Most of the analysis and interpretation I performed during this stage of the project was in the tests that I wrote. One of the tests I wrote for the User Model included generating 1000 new user emails and passwords and ensuring that all 1000 saved successfully. Even with encryption of all passwords, the test was able to complete in less than a second, which was a promising result when considering the deployment environment where there may be hundreds of new users signing on every second. 

\textit{Jeff's Contribution}

Included in the rails framework is the ability to write tests for all of the different models that we create.  In order to confirm the functionality of our models and the associated database, we developed a number of test files that would create instances of our models, manipulate them in some way (add, edit, or delete specific fields of the model), and then display the result.  In confirmation of our model design and function, we developed different data schemes to test and analyzed their outcomes to make sure that our implementation was sound.

\textit{Henrique's Contribution}

Most of my tests were conducted over a terminal development enviroment or graphically. The idea was to find out if the controllers were generating consistent data according to the user actions. The most important mechanic of our database is to create a subscription for each new event to bond it with a specific user. Therefore a single event may have several subscriptions including the one of its own creator. This design allows for users to flexibly modify some aspects of the event (i.e. adding and alarm or tag) without necessarily altering the original one. To accomplish that, I have written the controller such that for every event created, a corresponding subscription would be created as well. Over the "show" method of the controller, I also displayed the subscription information to get a graphical feedback of whether the design was working or not. 

\subsection{Designed System Component to Meet Desired Needs}

\textit{Brian's Contribution}

One of the core components that our team collaborated on heavily was the data representation in the back-end. Henrique and I were the only two members with experience in database programming, so we were able to guide the discussions in the right direction. After many white-board sessions, as a team we were able to establish a robust model representation that we later translated into a series of Ruby models and database migrations. 

\textit{Jeff's Contribution}

Our team as a whole spent many hours designing our database schema and model to make sure that our design had the ability to meet all the desired needs specified by the evolution document.  Although not every single requirement was implemented perfectly by the specified deadline, we our confident that our design deals with every possible relationship necessary to facilitate the completion of the requirements.

\textit{Henrique's Contribution}

The Subscription features linked with an User and an Event is not complete, even though the concept is well defined. The lack of familiarity of all the languages involved on Rails drew us back to meet all the required needs. Nevertheless, an Event has all its basic funcitonality working properly and integrated with its foreign key objects. A subscription already discerns its visibility although the only case treated on the controller is whether another user's Event has a corresponding private Subscription or not. 

\subsection{Deal with Realistic Constraints}

\textit{Brian's Contribution}

One of the crucial design considerations for our group was the selection of language and framework for our development environment. No one on the team had had much (if any) experience with web development, so given the time constraints and project requirements, it was important that we used an environment with extensive libraries and resources, a large community, and good documentation. Initially, we ended up starting with Django and Python due to two team members background in Python. However, due to the reasons stated above we came to realize that Ruby On Rails met our needs far greater than Django and Python, and justified our switch. 

\textit{Jeff's Contribution}

The fact that we made a decision part way through the development process to switch from a Django framework to a Rails framework made the time of total development much smaller.  This restraint required us to quickly design our new model in Rails while still having to consider good design principles in what we decided to implement.

\textit{Henrique's Contribution}

Django seemed as promising as any other language to start the project. I came late to the group and by that time the team had already decided on implementing the calendar on Django. However, I did not sense a lot of progress over the first week and decided to make a test by putting a simple interface up. I never lost so much time fixing configurations and not actually coding. Therefore, I decided to try on Rails, which took me less than half the time to do much more. By that time, I had lost three nights that could be used for working on the calendar. After that, I sat with my team to migrate their project to Rails. Nevertheless, understanding the MVC logic in Rails was not easy. We have not accounted that the task would be that complex. It was not for lack of time spent, I must have worked 30 hours on it, but for the lack of organization and previous learning. What happened was that we had spent our first weeks learning Django only to move to Rails later with no previous knowledge. I have asked some Rails programmers about the best ways to get started and compiled a set of tutorials that I intend to distribute to my team members before we proceed with development. Evolution 1 might not have been the most successful one, but the game is not over yet.

\subsection{Contributed to Team Work and Interacted with Team Members}

\textit{Brian's Contribution}

I often acted as the mediator and organizer of the group. I set up a Trello page to help us with Project Management and task delegation. I also hosted most of our major hacking sessions at my apartment, which helped foster collaboration in the group. I also attended all meetings and contributed greatly to the design and implementation of the back-end model, business logic, and model-controller API. 

\textit{Jeff's Contribution}

I attended every single team meeting and highly contributed to the initial model design.  Specifically, I helped white board out the model and collaborated with Henrique on integrating aspects of how events are displayed and how the overall look and feel of the application should be.

\textit{Henrique's Contribution}

I have been present in every team meeting and worked overnights to just get the project started. I could not accept so many configuration and terminal errors on my screen. Furthermore, I realized that other team members were also getting frustrated and for not being able to run anything. Therefore I proposed to work on a new solution that we would all implement if they agreed that it was viable. The team agreed promptly once I showed a simple calendar running in Rails and we migrated the project right away. Besides that, I have implemented mos of the front end except for the login validation. I have implemented the logic of adding events, linking them to the respective subscriptions and users on the database. I have also implemented the visibility parameters on subscriptions and visualizing other users. At first I would make the users clickable such that you then see their events apart from yours. Currently, it is possible to see the events of all users that are not private to yourself. However, this logic is still something that requires some more elaboration.

\section{Next Steps}


\end{document}